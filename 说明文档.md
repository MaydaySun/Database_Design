# 表结构说明

数据库内共分为9个表，如下所示：

1. ##### department

   ```mysql
   department(
       dept_id   varchar(8)  not null,
       dept_name varchar(20) not null, -- 部门编号和名称不能为空
       primary key (dept_id)
   )
   ```

   - ***department* **简单地使用`dept_id`作为主键，用于标识一个部门

2. ##### employee

   ```mysql
   employee(
       id              varchar(11)     not null,
       name            varchar(10)     not null, -- 员工的id和姓名不能为空
       gender          varchar(1)      check ( gender in (null, '男', '女') ),-- 性别可以不填，或者填入'男'、'女'
       age             int,
       date_employed   TIMESTAMP       default current_timestamp, -- 默认认为该员工是今天才录取的
       city            varchar(4),
       phone_number    varchar(11),
       email           varchar(50),
       dept_id         varchar(8)      not null,
       primary key (id),
       index (name),
       index (dept_id),-- 为name和department_id建立索引
       foreign key (dept_id) references department (dept_id)
           on delete cascade
           on update cascade
   )
   ```

   - ***employee*** 使用了员工号即`id`唯一标识一个员工。dept_id用作外键，引用了department表的一个记录中的dept_id，保证员工属于一个存在的部门。该外键使用了**级联删除与更新**，即在一个员工未被移出其部门之前，部门的编号改变或部门被删除都将导致员工信息从*employee* 表中删除。（设想公司的大规模裁员中一个整个部门都被裁掉，这种情况是可能的）

     注意其中对`name`的非空约束限制了一个员工必须具有姓名，最长10位的限制符合对人名的直观认知。

     对于枚举属性`gender`，通过一个check子句将值限制在"男"、"女"或null中（这允许一个员工不在个人信息透露性别，隐私保护get√^_^）

3. ##### manager

   ```mysql
   manager(
       employee_id     varchar(11)     not null,
       name            varchar(10)     not null, -- name其实是一个冗余属性，但可以便于获取一个部门主管的名字
       dept_id         varchar(8)      not null, -- 部门主管对应的部门id不能为空
       primary key (employee_id),
       unique (dept_id), -- 一个部门只能有一个部门主管，所以department_id需要唯一性约束
       foreign key (employee_id) references employee (id)
           on delete cascade -- 当employee信息变动，manager对应的信息也级联改动
           on update cascade,
       foreign key (dept_id) references department (dept_id)
       	on delete cascade
       	on update cascade
   )
   ```

   - ***manager*** 使用`employee_id`作为主键，并引用*employee* 表中的id，表示manager也是一个现存的员工。同*employee* 中的`dept_id`一样，*manager* 中也维护着其对应的`dept_id`。这两个外键均设置级联更新和删除。正如在*employee* 中提到的一样，可能发生manager的个人信息改变或部门信息的改变使得manager需要做出相应改变。

     *manager* 表中的`dept_id`添加了`唯一性约束`，这代表了一个部门只能有一个部门主管。在mysql中，添加唯一性约束的键，会自动设置一个索引，而不需再手动设置索引。可以预见到，这个索引将在manager通过`dept_id`找到本部门的所有员工或指定员工时，起到重要作用。

     注意在*manager* 中的`name`和`department`属性：这其实是一个违背设计范式的冗余，因为它们可以通过查询*employee* 表获得（使用employee_id的自然连接）。但是在此处，考虑到系统的可扩展性：一个系统用户（比如总裁）在将来可能需要获知所有部门主管的id和名字，在*manager* 表中维护一个`name`与`department`属性（与employee表中一致）显然更加直观。这将为将来的系统维护者带来更大的好处。

4. ##### instructor

   ```mysql
   instructor(
       employee_id     varchar(11)     not null,
       name            varchar(10)     not null,
       date_registered TIMESTAMP   default current_timestamp,
       primary key (employee_id),
       foreign key (employee_id) references employee (id)
           on delete cascade
           on update cascade
   )
   ```

   - ***instructor*** 类似于manager，我们同样地增加了`name`这一冗余属性以增强直观性和可扩展性，以及对外键`employee_id`设置的级联属性。除此以外的`data_registered`属性代表教员的任教时间，是教员的重要特征之一。

5. ##### course

   ```mysql
   course(
       course_id       varchar(7)      not null,
       title           varchar(20)     not null, -- 课程编号和名称不能为空
       type            varchar(10)     default '尚无分类', -- 课程类型
       content         varchar(50)     default '尚无描述',
       instructor_id   varchar(11)     not null, -- 一门课只有一个教员教授，以instructor_id作为course的属性即可
       primary key (course_id),
       foreign key (instructor_id) references instructor (employee_id)
           on delete cascade
           on update cascade
   )
   ```

   - ***course*** 将课程编号作为主键，并设置了非空属性`title`和`instructor_id`，分别代表课程名称和教员的员工号。

     对于course与教授该课程的instructor之间的关系，一个可能的想法是用一个关联表记录instructor与course之间的一对多关系。然而一个course只能有一个instructor的限制使得将`instructor_id`作为course的外键属性成为可能。这甚至可能更符合直觉：`一个instructor是一个course的重要特征之一`。

     类似上述表中所做的一样，我们也为`instructor_id`设置了级联删除与级联更新，这表示一个course的instructor信息不会因为instructor的员工号改变而丢失。

6. ##### test_record

   ```mysql
   test_record( -- 单次测试的记录
       record_id       bigint          not null    auto_increment, -- 测试记录可能会很多，使用bigint
       course_id       varchar(7)      not null,
       employee_id     varchar(11)     not null,
       score           int             not null    check ( score >= 0 and score <= 100 ), -- 当某次测试的score达到60需要更新takes表中对应记录为已通过
       PRIMARY KEY (record_id)
   )
   ```

   - ***test_record*** 记录了培训成绩。一个employee可能参加了多个course的多次测试，这将导致即使是对同一个employee和同一个其修读的课程，也可能不止有一个培训成绩。`(course_id, employee_id)`的二元组显然不能成为*test_record* 的主键。因此我们采用了针对单次培训成绩的唯一性标识符`record_id`作为主键。

```sql
test_record( -- 单次测试的记录
    record_id       bigint          not null    auto_increment, -- 测试记录可能会很多，使用bigint
    course_id       varchar(7)      not null,
    employee_id     varchar(11)     not null,
    score           int             not null    check ( score >= 0 and score <= 100 ), -- 当某次测试的score达到60需要更新takes表中对应记录为已通过
    PRIMARY KEY (record_id)
)

log(
    log_id      int             not null    auto_increment,
    username    varchar(10)     not null    default 'admin', -- 操作者的姓名，若不是员工操作，默认值为admin操作
    content     varchar(30)     not null,
    time        TIMESTAMP       default current_timestamp, -- 日志时间戳
    primary key (log_id)
)

takes(
    employee_id     varchar(11)     not null,
    course_id       varchar(7)      not null,
    completed       int             not null    default 0   check ( completed in (0, 1)),-- 结课状态，默认为未结课。
    -- 结课状态针对的是(employee_id, course_id)即一个员工是否学习完了该课程，而不是该课程是否已经结束并注销
    -- 直到管理员将此课程从course表中移除，代表该课程已注销
    is_passed       int             check ( is_passed in  (null, 0, 1)), -- 培训的通过状态
    primary key (employee_id, course_id),
    foreign key (employee_id) references employee (id)
        on delete cascade
        on update cascade,
    foreign key (course_id) references course(course_id)
        on delete cascade
        on update cascade
)

course_to_dept( -- 课程与部门的关联表
    course_id       varchar(7)      not null,
    dept_id         varchar(8)      not null,
    required        varchar(2)      not null    check ( required in ('必修', '选修')),
    primary key (course_id, dept_id),
    foreign key (course_id) references course (course_id)
        on delete cascade
        on update cascade,
    foreign key (dept_id) references department (dept_id)
        on delete cascade
        on update cascade
)
```

